import logging
import socket
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import ParseError
from ciscomation.ciscomation_exc import CiscomationException
from Exscript.protocols.drivers import driver_map

KEYWORDS = {
    '--print-next': {
        'mp_compat': False,
        'descr': 'Will print the result of next command'
    },
    '--pause': {
        'mp_compat': False,
        'descr': (
            'After the execution of command block will prompt you to go futher'
            ', or stop.'
        )
    },
    '--multiline-start': {
        'mp_compat': True,
        'descr': (
            'start multiline input without waiting for prompt, as example you '
            'can use it to set the banner. You have to use --multiline-stop '
            'if you are using --multiline-start.'
        )
    },
    '--multiline-stop': {
        'mp_compat': True,
        'descr': (
            'stops --multiline-start mode and sends the buffered lines to the '
            'device then wait for the prompt.'
        )
    },
    '--sleep-': {
        'mp_compat': True,
        'descr': 'Will sleep for xx seconds'
    },
    '--ignore-error': {
        'mp_compat': True,
        'descr': 'Will ignore any error generated by following command.'
    }
}


def check_mp_commands(commands):
    '''
    Cheching that all commands passed or multi process compatible. And if using
    special command checks that they are known.
    '''
    mp_compat = True
    for command in commands:
        cln_cmd = command.strip()
        if cln_cmd.startswith('--'):
            if cln_cmd.startswith('--sleep-'):
                cln_cmd = cln_cmd[0:8]
            try:
                mp_compat = mp_compat and KEYWORDS[cln_cmd]['mp_compat']
            except KeyError as e:
                print("Invalid command detected: {}".format(command))
                raise e
        else:
            continue
    return mp_compat


def hostname_resolves(hostname):
    try:
        ip = socket.gethostbyname(hostname)
        return (True, ip)
    except socket.error:
        return (False, None)


def xml_to_maintenance(filname):
    '''
    Reading xml to prepare a maintenance. Then plays teh maintenance. Get the
    feedback. and give a general status + detailed status.
    '''
    logger = logging.getLogger()
    maintenance = {
        'actions': [],
        'mp_compat': True
    }

    try:
        root = ET.parse(filname).getroot()
    except ParseError as e:
        logger.critical("Impossible to read xml file")
        print("last successful: {0}".format(e))
        raise e

    mp_compat = True
    for child in root:
        commands = ''
        pause = False
        if child.tag == 'switch':
            for prop in child:
                if prop.tag == 'name':
                    name = prop.text
                    valid_host, ip = hostname_resolves(name)
                    if not valid_host:
                        logger.critical(
                            'Could not resolve {}. Ignoring it.'.format(name)
                        )
                        break
                elif prop.tag == 'commands':
                    commands = [li for li in prop.text.splitlines()]
                    if not commands[0].strip():
                        commands = commands[1:]
                        logger.debug(
                            "{} First command was empty.".format(name)
                        )
                    mp_compat = mp_compat and check_mp_commands(commands)
                elif prop.tag == 'driver':
                    driver = prop.text
                    if driver not in driver_map.keys():
                        logger.critical('The driver {} set for switch {} was not found'.format(driver, name))
                        raise CiscomationException('The driver {} set for switch {} was not found'.format(driver, name))
                elif prop == 'pause':
                    pause = True
                    mp_compat = False
            maintenance['mp_compat'] = maintenance['mp_compat'] and mp_compat
            maintenance['actions'].append(
                {
                    'swname': name,
                    'ip': ip,
                    'commands': commands,
                    'driver': driver,
                    'pause': pause
                }
            )
            logger.info('Maintenance now includes host {}'.format(name))
        else:
            raise CiscomationException('unknown xml tag {}'.format(child.tag))
    if not maintenance['mp_compat']:
        logger.warning('Maintenance not compliant with multi processing')
    return maintenance
